diff --git a/src/arrayvec_copy_generated.rs b/src/arrayvec_copy.rs
index f61b5b3..fab45ec 100644
--- a/src/arrayvec_copy_generated.rs
+++ b/src/arrayvec_copy.rs
@@ -23,10 +23,12 @@ use serde::{Serialize, Deserialize, Serializer, Deserializer};
 use crate::LenUint;
 use crate::errors::CapacityError;
 use crate::arrayvec_impl::ArrayVecImpl;
-use crate::utils::MakeMaybeUninit;
 
 /// A vector with a fixed capacity.
 ///
+/// **Its only difference to [`ArrayVec`](crate::ArrayVec) is that its elements
+/// are constrained to be `Copy` which allows it to be `Copy` itself.**
+///
 /// The `ArrayVecCopy` is a vector backed by a fixed size array. It keeps track of
 /// the number of initialized elements. The `ArrayVecCopy<T, CAP>` is parameterized
 /// by `T` for the element type and `CAP` for the maximum capacity.
@@ -46,14 +48,6 @@ pub struct ArrayVecCopy<T: Copy, const CAP: usize> {
     xs: [MaybeUninit<T>; CAP],
 }
 
-impl<T: Copy, const CAP: usize> Drop for ArrayVecCopy<T, CAP> {
-    fn drop(&mut self) {
-        self.clear();
-
-        // MaybeUninit inhibits array's drop
-    }
-}
-
 macro_rules! panic_oob {
     ($method_name:expr, $index:expr, $len:expr) => {
         panic!(concat!("ArrayVecCopy::", $method_name, ": index {} is out of bounds in vector of length {}"),
@@ -87,20 +81,6 @@ impl<T: Copy, const CAP: usize> ArrayVecCopy<T, CAP> {
         }
     }
 
-    /// Create a new empty `ArrayVecCopy` (fn).
-    ///
-    /// The maximum capacity is given by the generic parameter `CAP`.
-    ///
-    /// ```
-    /// use arrayvec::ArrayVecCopy;
-    ///
-    /// static ARRAY: ArrayVecCopy<u8, 1024> = ArrayVecCopy::new_const();
-    /// ```
-    pub fn new_const() -> ArrayVecCopy<T, CAP> {
-        assert_capacity_limit_const!(CAP);
-        ArrayVecCopy { xs: MakeMaybeUninit::ARRAY, len: 0 }
-    }
-
     /// Return the number of elements in the `ArrayVecCopy`.
     ///
     /// ```
@@ -964,21 +944,6 @@ impl<T: Copy, const CAP: usize> DoubleEndedIterator for IntoIter<T, CAP> {
 
 impl<T: Copy, const CAP: usize> ExactSizeIterator for IntoIter<T, CAP> { }
 
-impl<T: Copy, const CAP: usize> Drop for IntoIter<T, CAP> {
-    fn drop(&mut self) {
-        // panic safety: Set length to 0 before dropping elements.
-        let index = self.index;
-        let len = self.v.len();
-        unsafe {
-            self.v.set_len(0);
-            let elements = slice::from_raw_parts_mut(
-                self.v.get_unchecked_ptr(index),
-                len - index);
-            ptr::drop_in_place(elements);
-        }
-    }
-}
-
 impl<T: Copy, const CAP: usize> Clone for IntoIter<T, CAP>
 where T: Clone,
 {
